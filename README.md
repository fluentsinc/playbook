# **Basic Information**

## **About `playbook`**
___

### `playbook` is an experimental, prototypical concept-recall playbook that was created to _**take advantage of**_ of some unique concept formation strategies that most people unconciously use when learning new concepts elsewhere in life. The `playbook` was conceptualized _**from the ground up**_ to exploit concept-recall strategies such as spaced-repetition and word-to-abstract-concepts association. 

### _**From the get-go,**_ the play calling system of `playbook` was designed to primarily reduce _**verboseness**_ and create clarity when we _**set out**_ to perform complex programming maneuvers. The `playbook` contains lots of plays that you need to execute as a professional software **player**. The `playbook` was planned with some objectives in mind like thoroughness, usability and clarity. The learning curve for `playbook` could be _**steep**_ at the start since you need to _**take a lot of things in** as you are _**going through the playbook**_. Nonetheless, when you figure out the playbook it'll get easier, you'll tend to realize the power behind spaced-repetition and word-to-abstract-concepts assocication. The `playbook` works _**hand in hand**_ with the **"experiments"** repositories on `fluentsinc`: you would work with `rookie-experiments` at the start but eventually you would work mostly _**in tandem**_ with `prometheus-experiments`. It's absolutely neccessary that you _**get a good grip on**_ concepts found in "experiments" repositories so that you can start using the `playbook` effectively. 

### The language of `playbook` could be thought of as a `futuristic high level language` but technically it's not a programming language. It's a concept-recall language that lets you effectively _**make use of**_ high level and low level programming languages. Java, Python, Ruby, Javascript are all examples of current high level languages. These languages don't talk to the computer hardware directly hence, high level.  C, C++ are examples of low level languages. These languages talk directly to the computer hardware hence, low level and considered "dangerous" since you can really mess up your computer if you don't know what you're doing. 
___

## **How to use the `playbook`**

### The playbook contains loads of **plays** and **play calls** that you would find crucial going forward saving precious time and effort. The playbook keeps all the **plays** and **play calls** categorically in a directory structure. 

### For example, if there's a play or a play call related to "html", you would go into the `playbook/html` folder to see all the plays and play calls in files named "html-plays.md" and "html-playcalls.md" respectively. You would also see "html/code-words.md" file which contains code words specific to "html". Note: the codewords in `base` folder are applicable to every other technology.

### You would also see a folder named "base" in `playbook`. This is such an important folder for us because all the plays and play calls in the "base" folder are methodically defined to accurately execute the entire playbook. The base plays, play calls and code words are used in combination with the other plays, play calls and code words in the playbook to create combinations of play calls that solve real practical problems. 

### Go through the **common descriptions** section carefully since a very good understanding of these basic descriptions is needed to understand the playbook.  

## **Common Descriptions**

### **play** 

### any linear(straightforward) step or steps you would take to accomplish something you want to do. Linear steps are nothing but assignments that you need to follow in a predefined sequence to accomplish something. So for the first linear step you would do something and the second linear step you would do something else and so on and so forth until you get the job done. Plays are usually a word or words that signal you to follow some predefined linear steps. 

### For example, there are linear steps that you can take to create a text file with your name written on it. The steps could be: 1. you would create a text file by using notepad or wordpad, 2. Once you've created a new text file, you would write your name on it. Let's say, we give a name "text-x" to the above linear steps(play). Then when you get assigned a play "text-x", your job is to execute the above two linear steps defined for that "text-x" play. 

### Another example could be driving a car. The linear steps for driving a car are: 1. open the door 2. get into the driver's seat. 3. insert the keys 4. start the engine. 5. drive. We could call the car driving play (linear steps) as "bugatti". So when you get assigned a play "bugatti", your job is to follow all the linear steps and get the job done by following the linear step defined above. 

### **play call** 

### a play call refers to group of plays put together in a sentence. For example, `call team |java| asap` is a play call which contains three plays in it. You need to perform the play call as defined in the playbook. The individual plays might be executed differently when called in a play call so don't assume you can just execute the plays to complete the play call. Always refer the `playcalls.md` file in each technology to see the complete definition and sequence for a play call.  

### a play call could also refer to multiple lines of play calls. In a multi-line play call, the play calls follow a predefined sequence which you should always follow. For example, when we call "call all teams asap" multi-line play call, you need to execute all the play calls defined for that multi-line play call in the order that it appears. Look at the play calls defined for `call all teams asap` multi-line play call:

```
call team A asap
call team ux asap
call team java asap
call team rookie asap
```

### All the lines of play calls you see above are defined in a specific order for multi-line play call `call all teams asap`. Your job in this scenario is to execute the play calls one by one in the order you see. So to execute `call all teams asap` play call, you would execute `call team A asap` play call first, then you would execute `call team ux asap` second so on and so forth until you reach the last play call. 

### Going forward, all the programming tasks or assignments that you get will be play calls. 

### **play caller**

### the one who calls the **play calls**. 

### **player**

### any human that can follow and execute linear steps effectively. 

### **experiment**

### Just as a scientific experiment, the "experiment" is a do-observe-reflect-learn kind of activity. You do some things, you observe what happened, you reflect back on why that happened and you learn why it happened. An "experiment" is an active activity where you are learning some theory or actively doing some steps to learn. 

### **pilot**

### A "pilot" gathers up several experiments into a combined learning activity. Completing each "pilot" makes you master a "technology".     

### **technology**

### "technology" refers to a programming language or a software. High level abstractions(remembering only useful information) of "technology" is usually found as a folder in "experiments-repository". All the folders inside the "experiments-repository" are technologies. Inside each technology, you will find lots of pilots that strives to make you master the technology.

### **experiments-repository**

### The "experiments-repository" contains high level abstractions(remembering only useful information)of several high level technologies and its related concepts. 

### **pilot-number**

### The **pilot-number** is a number written next to "pilot-". It helps you accurately identify the pilots inside a **technology**. For example, you would usually find the pilots by the number next to it like so: `pilot-01` to mean the first pilot in a technology or `pilot-10` to mean the tenth pilot in a technology. 

### *experiment-number**

### The "experiment-number** is a number 

### **syntax**

### The syntax is a term we use to refer to templates or patterns. For example, in English, we say "are they coming?" not "they coming are?". Switching up the words would mean something totally different. Likewise, in programming, we use syntax to define what pattern or template that we want. For example, the syntax to create a Git commit is `git commit -m "some message"`. Here, the syntax is `git commit -m`. "some message" could contain any words.  

## **Code Words**

### Code words are normal words that mean something in the playbook. For example, code word "Rookie-X" could mean `rookie-experiments` repository. The code words always start with an uppercase letter as you can see in "Rookie-X". That's how you could recognize that you're dealing with a code word. If the code word has multiple words separted by a hyphen, then the new word also starts with an uppercase letter like so: `Prom-X`. There are two types of code words you would see: constant and variable. Always refer the `codewords.md` file inside each technology folder. Codewords.md files are usually saved as `folder-name-codewords.md`. For example, take a look at `rookie-codewords.md`. 

### **Constant Code Words**

### Constant code words are code words where you would fill a specific word in place of the code word. 

### For example, let's say the code word definition maps the word "Cat" to "https://www.google.com" then if you see "Cat" anywhere on the playbook, you should realize that we mean "https://www.google.com" and replace "Cat" with "https://www.google.com" . 

### Cat is the code word. `https://www.google.com` is the specific word that you need to fill in everywhere you see "Cat". 

### Syntax: `Constant-Code-Word` => `specific-word`
### Example: `Knight` => `https://www.behance.com` - the largest design portfolio showcasing website

### Pay attention to the example, that's how the codewords are written in `codewords.md` file inside every folder. `Knight` is the constant code word. `https://www.behance.com` is the specific word that you would put in. The line `the largest design portfolio showcasing website` defines the specific word. 

### **Literal Words**

### Literal words are words that need to be filled in _**literally**_(exact words) as it appears. They are always lowercased.  

### For example, `fluentsinc/` could be considered a literal code word in the variable code word `fluentsinc/[Time]`

### Literal words are also used to define a lowercased word that is short for verbose definitions.

### For example, `fluentsinc` => `refers to an organization on Github named "fluentsinc". Repositories on this organization are referred to as a directory like so: **fluentsinc/playbook** to mean the "playbook" repository in "fluentsinc" organization`

### **Variable Code Words**

### Variable code words are code words that vary according to a predefined filler rule. The filler rule tells you that you need to fill some things into the brackets [] to _**make sense of**_ of the code word. 

### For example, in this variable code word below. 

### **[Repository-Name]** is the variable code word. 

### **fluentsinc/[Repository-Name]** is a literal word with variable code word. 

### [Repository-Name] is the repository name that you need to fill next to "fluentsinc/" without the brackets. For example, if the [Repository-Name] is `moon`, it should be filled in as `fluentsinc/moon`. 

### **syntax:** `literal-word-[Variable-Code-Word]` => `literal-word-filler-word`
### **example:** `fluentsinc/[Repository-Name]` => `fluentsinc/repo-name`
### **definition:** `[Repository-Name]` - the name of the repository that you need to fill next to "fluentsinc/". 

### Pay close attention to all the symbols used like =>, - and []. When you refer `codewords.md` file, the symbols follow the same meaning as you see here. `=>` symbol here refers to the change that happens to the word on the left of it. `-` tells us that whatever comes afer the hyphen is a definition of the word left of the hyphen. Also, the syntax, example and definition for all codewords are given in the above format so that knowing what a code word means would be pretty easy.  

